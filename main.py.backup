"""
ç®€åŒ–ç‰ˆä¸»ç¨‹åº - å®Œå…¨ä¿¡ä»»AIçš„åˆ¤æ–­
"""
import time
from datetime import datetime
from typing import Dict, Optional
from openai import OpenAI

from config import DEEPSEEK_API_KEY, DEEPSEEK_BASE_URL, TRADING_CONFIG, validate_config
from pure_ai_trader import PureAITrader
from utils.data_fetcher import DataFetcher
from utils.indicators import calculate_technical_indicators, format_market_data
from trade_database import TradeDatabase
from mcp_sync import MCPDatabaseSync
from trading_executor import TradingExecutor
from position_manager import PositionManager
from order_sync import OrderSync


class SimpleAITradingBot:
    """ç®€åŒ–ç‰ˆAIäº¤æ˜“æœºå™¨äºº - çº¯AIé©±åŠ¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–äº¤æ˜“æœºå™¨äºº"""
        print(f"\n{'='*70}")
        print("[AI] åˆå§‹åŒ–AIäº¤æ˜“æœºå™¨äºº")
        print(f"{'='*70}\n")
        
        # éªŒè¯é…ç½®
        validate_config()
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.ai_client = OpenAI(api_key=DEEPSEEK_API_KEY, base_url=DEEPSEEK_BASE_URL)
        self.ai_trader = PureAITrader(self.ai_client)
        self.data_fetcher = DataFetcher()
        self.trade_db = TradeDatabase()
        
        # åˆå§‹åŒ–MCPä¸æ•°æ®åº“åŒæ­¥å™¨
        self.mcp_sync = MCPDatabaseSync(self.ai_trader.mcp_memory, self.trade_db)
        print("[åŒæ­¥] MCPæ•°æ®åº“åŒæ­¥å™¨å·²åˆå§‹åŒ–")
        
        # åˆå§‹åŒ–æ–°æ¨¡å—
        self.trading_executor = TradingExecutor(self.data_fetcher, self.trade_db)
        self.position_manager = PositionManager(self.data_fetcher, self.trade_db)
        self.order_sync = OrderSync(self.data_fetcher, self.trade_db)
        
        # åŠ è½½å†å²MCPè®°å¿†
        try:
            self.ai_trader.mcp_filesystem.import_mcp_memory(self.ai_trader.mcp_memory)
            print("[åŠ è½½] MCPå†å²è®°å¿†å·²åŠ è½½")
        except Exception as e:
            print(f"[è­¦å‘Š] åŠ è½½MCPè®°å¿†å¤±è´¥: {e}")
        
        # çŠ¶æ€
        self.current_trade_id = None
        self.cycle_count = 0
        
        # æŒ‡æ•°é€€é¿ç›¸å…³
        self.consecutive_holds = 0  # è¿ç»­HOLDæ¬¡æ•°
        self.skip_cycles = 0  # éœ€è¦è·³è¿‡çš„å‘¨æœŸæ•°
        
        # å®‰å…¨æœºåˆ¶ï¼šè®°å½•å¾…ç¡®è®¤çš„å¼€ä»“å†³ç­–ï¼ˆæ”¯æŒå¤šä¸ªå¸ç§ï¼‰
        self.pending_open_decisions = {}  # {'BTC': {'signal': 'BUY', 'cycle': 123}, 'ETH': {...}}
        
        print("\n" + "="*70)
        print("åˆå§‹åŒ–å®Œæˆ")
        print("="*70 + "\n")
    
    def run_cycle(self):
        """è¿è¡Œä¸€ä¸ªäº¤æ˜“å‘¨æœŸ"""
        try:
            self.cycle_count += 1
            
            # æŒ‡æ•°é€€é¿ï¼šå¦‚æœéœ€è¦è·³è¿‡æœ¬å‘¨æœŸ
            if self.skip_cycles > 0:
                self.skip_cycles -= 1
                print(f"\n{'='*70}")
                print(f"â­ï¸  å‘¨æœŸ #{self.cycle_count} - è·³è¿‡AIåˆ†æï¼ˆè¿ç»­HOLDä¼˜åŒ–ï¼‰")
                print(f"   å‰©ä½™è·³è¿‡å‘¨æœŸ: {self.skip_cycles}")
                print(f"{'='*70}\n")
                return
            
            print(f"\n{'='*70}")
            print(f"å‘¨æœŸ #{self.cycle_count} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"{'='*70}\n")
            
            # 1. è·å–å¤šå¸ç§å¸‚åœºæ•°æ®
            all_market_data = {}
            
            for symbol in TRADING_CONFIG['symbols']:
                coin = symbol.split('/')[0]  # æå–å¸ç§åç§° (BTC, ETH)
                # print(f"\nğŸ“¡ è·å–{coin}æ•°æ®...")  # é™é»˜æ¨¡å¼
                
                # ä¸´æ—¶åˆ‡æ¢äº¤æ˜“å¯¹
                original_symbol = self.data_fetcher.symbol
                self.data_fetcher.symbol = symbol
                
                # è·å–15åˆ†é’Ÿæ•°æ®
                df_15m = self.data_fetcher.fetch_ohlcv('primary')
                if df_15m is None:
                    print(f"[å¤±è´¥] {coin} 15åˆ†é’Ÿæ•°æ®è·å–å¤±è´¥")
                    self.data_fetcher.symbol = original_symbol
                    continue
                
                # è·å–4å°æ—¶æ•°æ®
                df_4h = self.data_fetcher.fetch_ohlcv('long')
                
                # è·å–æ—¥çº¿æ•°æ®ï¼ˆ7å¤©ï¼‰
                df_1d = self.data_fetcher.fetch_ohlcv('daily')
                
                # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
                df_15m = calculate_technical_indicators(df_15m)
                if df_4h is not None:
                    df_4h = calculate_technical_indicators(df_4h)
                if df_1d is not None:
                    df_1d = calculate_technical_indicators(df_1d)
                
                # æ ¼å¼åŒ–æ•°æ®
                coin_data = format_market_data(df_15m)
                if df_4h is not None:
                    coin_data['long_timeframe'] = format_market_data(df_4h)
                if df_1d is not None:
                    coin_data['daily_timeframe'] = format_market_data(df_1d)
                
                all_market_data[coin] = coin_data
                
                # æ ¹æ®ä»·æ ¼å¤§å°åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºç²¾åº¦
                price = coin_data['price']
                if price < 0.01:
                    price_str = f"${price:.6f}"
                elif price < 1:
                    price_str = f"${price:.4f}"
                elif price < 100:
                    price_str = f"${price:,.2f}"
                else:
                    price_str = f"${price:,.0f}"
                print(f"{coin}å½“å‰ä»·æ ¼: {price_str}")
                
                # æ¢å¤åŸå§‹äº¤æ˜“å¯¹
                self.data_fetcher.symbol = original_symbol
            
            if not all_market_data:
                print("[å¤±è´¥] æ‰€æœ‰å¸ç§æ•°æ®è·å–å¤±è´¥ï¼Œè·³è¿‡æœ¬å‘¨æœŸ")
                return
            
            # 4. è·å–è´¦æˆ·ä¿¡æ¯
            balance_info = self.data_fetcher.fetch_balance()
            available_balance = 0  # å¯ç”¨ä½™é¢
            if balance_info:
                # ç›´æ¥ä»OKXè·å–è´¦æˆ·æƒç›Š
                # ä½¿ç”¨infoå­—æ®µä¸­çš„totalEqï¼ˆè´¦æˆ·æ€»æƒç›Šï¼‰
                if 'info' in balance_info and 'data' in balance_info['info']:
                    data = balance_info['info']['data']
                    if data and len(data) > 0:
                        # totalEqæ˜¯è´¦æˆ·æ€»æƒç›Šï¼ˆåŒ…å«æ‰€æœ‰æŒä»“çš„æœªå®ç°ç›ˆäºï¼‰
                        total_eq = data[0].get('totalEq', '0')
                        balance = float(total_eq) if total_eq else 0
                        
                        # availEqåœ¨è´¦æˆ·çº§åˆ«å¯èƒ½æ˜¯ç©ºçš„ï¼Œéœ€è¦ä»detailsä¸­è·å–USDTçš„å¯ç”¨ä½™é¢
                        avail_eq = data[0].get('availEq', '0')
                        if not avail_eq or avail_eq == '':
                            # ä»detailsä¸­æŸ¥æ‰¾USDTçš„availEq
                            details = data[0].get('details', [])
                            for detail in details:
                                if detail.get('ccy') == 'USDT':
                                    avail_eq = detail.get('availEq', '0')
                                    break
                        
                        available_balance = float(avail_eq) if avail_eq else 0
                    else:
                        balance = balance_info.get('USDT', {}).get('total', 0)
                        available_balance = balance_info.get('USDT', {}).get('free', 0)
                else:
                    balance = balance_info.get('USDT', {}).get('total', 0)
                    available_balance = balance_info.get('USDT', {}).get('free', 0)
            else:
                balance = TRADING_CONFIG.get('initial_balance', 200.0)
                available_balance = balance
            
            # 5. è·å–æ‰€æœ‰æŒä»“å¹¶åŒæ­¥æ•°æ®åº“
            all_positions = self.data_fetcher.get_all_positions()
            current_position = all_positions[0] if all_positions else None  # ä¿æŒå‘åå…¼å®¹
            
            # 5.1 ä»APIåŒæ­¥å†å²æˆäº¤åˆ°æ•°æ®åº“
            self.order_sync.sync_filled_orders_from_api()
            
            # 5.2 åŒæ­¥æ•°æ®åº“ï¼šå…³é—­æ‰€æœ‰ä¸åœ¨æŒä»“ä¸­çš„äº¤æ˜“
            self.position_manager.sync_database_with_positions(current_position)
            
            # æ˜¾ç¤ºæ‰€æœ‰æŒä»“
            if all_positions:
                print(f"å½“å‰æŒä»“æ•°é‡: {len(all_positions)}")
                for pos in all_positions:
                    amount = pos.get('btc_amount', 0)
                    if amount < 1:
                        amount_str = f"{amount:.4f}"
                    else:
                        amount_str = f"{amount:.2f}"
                    
                    print(f"   - {pos.get('symbol')} {pos.get('side')} {amount_str} | ç›ˆäº: ${pos.get('unrealized_pnl', 0):,.2f}")
            # else:
            #     print("[æ•°æ®] å½“å‰æ— æŒä»“")  # é™é»˜æ¨¡å¼ï¼Œæ— æŒä»“æ—¶ä¸æ‰“å°
            
            # 5.5 è®¾ç½®è´¦æˆ·ç»Ÿè®¡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            # TODO: ä»APIè·å–çœŸå®çš„è´¦æˆ·ç»Ÿè®¡
            # ç¤ºä¾‹æ•°æ®ï¼ˆæ›¿æ¢ä¸ºå®é™…APIè°ƒç”¨ï¼‰:
            # self.ai_trader.set_account_stats(
            #     total_return_pct=116.25,
            #     total_value=21624.9,
            #     sharpe_ratio=0.468,
            #     available_cash=13654.1,
            #     all_positions=[
            #         {'symbol': 'ETH', 'quantity': 5.74, 'entry_price': 4189.12, ...},
            #         {'symbol': 'BTC', 'quantity': 0.12, 'entry_price': 107343.0, ...},
            #         ...
            #     ]
            # )
            
            # 6. AIåˆ†æå¹¶å†³ç­–
            print("\n[AI] AIåˆ†æä¸­...\n")
            
            # ä¼ é€’å½“å‰äº¤æ˜“IDã€å‘¨æœŸå·å’Œå¾…ç¡®è®¤å†³ç­–ç»™AI
            self.ai_trader.current_trade_id = self.current_trade_id
            self.ai_trader.current_cycle = self.cycle_count
            self.ai_trader.pending_decisions = self.pending_open_decisions
            self.ai_trader.available_balance = available_balance  # ä¼ é€’å¯ç”¨ä½™é¢
            
            decision = self.ai_trader.analyze_multi_coins(
                all_coins_data=all_market_data,
                account_balance=balance,
                all_positions=all_positions
            )
            
            # 7. æ˜¾ç¤ºå†³ç­–
            self._display_decision(decision)
            
            # 8. æ£€æµ‹è¿ç»­HOLDå¹¶åº”ç”¨æŒ‡æ•°é€€é¿
            signal = decision.get('signal', 'HOLD')
            has_position = current_position is not None
            
            if signal == 'HOLD' and not has_position and TRADING_CONFIG.get('backoff_enabled', True):
                # æ— æŒä»“ä¸”HOLDï¼Œä¸”å¯ç”¨äº†é€€é¿
                self.consecutive_holds += 1
                
                # æŒ‡æ•°é€€é¿ç­–ç•¥
                threshold = TRADING_CONFIG.get('backoff_threshold', 3)
                max_skip = TRADING_CONFIG.get('backoff_max_skip', 8)
                
                if self.consecutive_holds >= threshold:
                    # è¾¾åˆ°é˜ˆå€¼åå¼€å§‹é€€é¿
                    # é€€é¿å‘¨æœŸ = min(2^(n-threshold+1), max_skip)
                    self.skip_cycles = min(2 ** (self.consecutive_holds - threshold + 1), max_skip)
                    print(f"\nğŸ’¤ è¿ç»­{self.consecutive_holds}æ¬¡HOLDï¼Œå¯åŠ¨æŒ‡æ•°é€€é¿")
                    print(f"   ä¸‹æ¬¡AIåˆ†æå°†åœ¨{self.skip_cycles + 1}ä¸ªå‘¨æœŸå")
            else:
                # æœ‰äº¤æ˜“ä¿¡å·æˆ–æœ‰æŒä»“ï¼Œé‡ç½®è®¡æ•°
                if self.consecutive_holds > 0:
                    print(f"\n[åŒæ­¥] æ£€æµ‹åˆ°äº¤æ˜“ä¿¡å·ï¼Œé‡ç½®é€€é¿è®¡æ•°")
                self.consecutive_holds = 0
                self.skip_cycles = 0
            
            # 9. æ‰§è¡Œä¸»è¦äº¤æ˜“å†³ç­–
            if decision.get('signal') != 'HOLD':
                symbol = decision.get('symbol', 'BTC')
                # æ¸…ç†symbolæ ¼å¼ï¼Œåªä¿ç•™å¸ç§åç§°
                if '/' in symbol:
                    symbol = symbol.split('/')[0]
                coin_data = all_market_data.get(symbol, {})
                self._execute_trade(decision, coin_data.get('price', 0), coin_data, all_market_data)
            
            # 10. æ‰§è¡ŒæŒä»“ç®¡ç†å»ºè®®ï¼ˆåŒ…æ‹¬å¹³ä»“ã€è°ƒæ•´æ­¢æŸæ­¢ç›ˆã€ä»¥åŠå¯èƒ½çš„æ–°å¼€ä»“ï¼‰
            position_reviews = decision.get('position_reviews', [])
            if position_reviews:
                if not TRADING_CONFIG.get('test_mode', False):
                    self._execute_position_reviews(position_reviews, all_market_data, all_positions)
                else:
                    print("\nğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šè·³è¿‡æŒä»“ç®¡ç†æ‰§è¡Œ")
            
            print(f"\n{'='*70}")
            print(f"å‘¨æœŸ #{self.cycle_count} å®Œæˆ")
            print(f"{'='*70}\n")
            
        except KeyboardInterrupt:
            raise
        except Exception as e:
            print(f"\n[å¤±è´¥] å‘¨æœŸæ‰§è¡Œå‡ºé”™: {e}")
            import traceback
            traceback.print_exc()
    
    def _sync_filled_orders_from_api(self):
        """ä»APIåŒæ­¥æœ€è¿‘çš„æˆäº¤è®¢å•åˆ°æ•°æ®åº“"""
        try:
            # è·å–æœ€è¿‘7å¤©çš„æˆäº¤è®¢å•
            from datetime import datetime, timedelta
            
            # print("\n[åŒæ­¥] å¼€å§‹ä»APIåŒæ­¥å†å²æˆäº¤...")  # é™é»˜æ¨¡å¼
            
            # è·å–æ‰€æœ‰äº¤æ˜“å¯¹çš„å†å²è®¢å•
            synced_count = 0
            for symbol in TRADING_CONFIG['symbols']:
                try:
                    # è·å–æœ€è¿‘çš„å·²æˆäº¤è®¢å•ï¼ˆä½¿ç”¨fetch_my_tradesè·å–å®é™…æˆäº¤ï¼‰
                    trades = self.data_fetcher.exchange.fetch_my_trades(
                        symbol=symbol,
                        since=int((datetime.now() - timedelta(days=7)).timestamp() * 1000),
                        limit=100
                    )
                    
                    if not trades:
                        continue
                    
                    # å…ˆæŸ¥æ‰¾æ•°æ®åº“ä¸­éœ€è¦åŒæ­¥çš„è®°å½•
                    import sqlite3
                    conn = sqlite3.connect(self.trade_db.db_path)
                    conn.row_factory = sqlite3.Row
                    cursor = conn.cursor()
                    
                    cursor.execute('''
                    SELECT * FROM trades 
                    WHERE symbol = ? AND (exit_price = 0 OR exit_price IS NULL)
                    ORDER BY open_time DESC
                    LIMIT 10
                    ''', (symbol,))
                    
                    db_trades_to_sync = [dict(row) for row in cursor.fetchall()]
                    conn.close()
                    
                    if not db_trades_to_sync:
                        continue
                    
                    print(f"  {symbol}: APIæœ‰{len(trades)}ç¬”æˆäº¤ï¼Œæ•°æ®åº“æœ‰{len(db_trades_to_sync)}ç¬”å¾…åŒæ­¥")
                    
                    # æŒ‰æ—¶é—´åˆ†ç»„ï¼Œæ‰¾å‡ºå¼€ä»“å’Œå¹³ä»“é…å¯¹
                    for api_trade in trades:
                        api_side = api_trade.get('side')  # buy/sell
                        api_price = api_trade.get('price', 0)
                        api_amount = api_trade.get('amount', 0)
                        api_time = datetime.fromtimestamp(api_trade.get('timestamp', 0) / 1000)
                        
                        # éå†æ•°æ®åº“ä¸­å¾…åŒæ­¥çš„è®°å½•
                        for db_trade in db_trades_to_sync:
                                # å¦‚æœæ˜¯å¹³ä»“è®¢å•ï¼ˆæ–¹å‘ç›¸åï¼‰ï¼Œæ›´æ–°å¹³ä»“ä¿¡æ¯
                                db_side = db_trade.get('side', 'long')
                                is_close_order = (db_side == 'long' and api_side == 'sell') or \
                                               (db_side == 'short' and api_side == 'buy')
                                
                                if is_close_order:
                                    # è®¡ç®—ç›ˆäº
                                    entry_price = db_trade.get('entry_price', 0)
                                    quantity = db_trade.get('quantity', 0)
                                    leverage = db_trade.get('leverage', 10)
                                    
                                    if entry_price and api_price and quantity:
                                        price_diff = api_price - entry_price if db_side == 'long' else entry_price - api_price
                                        realized_pnl = price_diff * quantity * leverage
                                        
                                        # æ›´æ–°æ•°æ®åº“
                                        import sqlite3
                                        conn = sqlite3.connect(self.trade_db.db_path)
                                        cursor = conn.cursor()
                                        
                                        cursor.execute('''
                                        UPDATE trades SET
                                            exit_price = ?,
                                            close_time = ?,
                                            realized_pnl = ?,
                                            pnl_percent = ?,
                                            status = 'CLOSED',
                                            updated_at = datetime('now')
                                        WHERE id = ?
                                        ''', (
                                            api_price,
                                            api_time.isoformat(),
                                            realized_pnl,
                                            (price_diff / entry_price) * leverage * 100,
                                            db_trade['id']
                                        ))
                                        
                                        # è®¡ç®—æŒä»“æ—¶é•¿
                                        open_time_str = db_trade.get('open_time')
                                        if open_time_str and api_time:
                                            try:
                                                open_time = datetime.fromisoformat(open_time_str)
                                                duration_seconds = (api_time - open_time).total_seconds()
                                                
                                                cursor.execute('''
                                                UPDATE trades SET
                                                    holding_duration_seconds = ?
                                                WHERE id = ?
                                                ''', (duration_seconds, db_trade['id']))
                                            except:
                                                pass
                                        
                                        conn.commit()
                                        conn.close()
                                        
                                        print(f"  [å®Œæˆ] åŒæ­¥æˆåŠŸ ID#{db_trade['id']}: å¼€ä»“${entry_price:,.2f} â†’ å¹³ä»“${api_price:,.2f} ç›ˆäº${realized_pnl:+,.2f}")
                                        synced_count += 1
                                        break
                
                except Exception as e:
                    # å•ä¸ªå¸ç§å¤±è´¥ä¸å½±å“å…¶ä»–å¸ç§
                    print(f"  [è­¦å‘Š] {symbol} åŒæ­¥å¤±è´¥: {e}")
            
            if synced_count > 0:
                print(f"[å®Œæˆ] åŒæ­¥å®Œæˆï¼Œæ›´æ–°äº†{synced_count}ç¬”äº¤æ˜“\n")
            # else:
            #     print("[ä¿¡æ¯]  æ²¡æœ‰éœ€è¦åŒæ­¥çš„äº¤æ˜“\n")  # é™é»˜æ¨¡å¼ï¼Œæ— éœ€æ‰“å°
                    
        except Exception as e:
            # åŒæ­¥å¤±è´¥ä¸å½±å“ä¸»æµç¨‹
            print(f"[è­¦å‘Š] APIåŒæ­¥å¤±è´¥: {e}\n")
    
    def _sync_database_with_positions(self, current_position: Optional[Dict]):
        """
        åŒæ­¥æ•°æ®åº“ä¸å®é™…æŒä»“
        å…³é—­æ‰€æœ‰åœ¨æ•°æ®åº“ä¸­æ ‡è®°ä¸ºopenä½†å®é™…å·²å¹³ä»“çš„äº¤æ˜“
        """
        try:
            # è·å–æ‰€æœ‰æœªå¹³ä»“çš„äº¤æ˜“
            open_trades = self.trade_db.get_open_trades()
            
            if not open_trades:
                return
            
            # å¦‚æœæ²¡æœ‰å®é™…æŒä»“ï¼Œå…³é—­æ‰€æœ‰æ•°æ®åº“ä¸­çš„æœªå¹³ä»“äº¤æ˜“
            if not current_position:
                for trade in open_trades:
                    # è·å–å½“å‰å¸‚åœºä»·æ ¼ä½œä¸ºå¹³ä»“ä»·
                    try:
                        symbol = trade['symbol']
                        # æ¸…ç†symbolæ ¼å¼
                        coin = symbol.split('/')[0]
                        symbol_clean = f"{coin}/USDT:USDT"
                        # ä½¿ç”¨ccxtçš„fetch_tickerè·å–å½“å‰ä»·æ ¼
                        ticker = self.data_fetcher.exchange.fetch_ticker(symbol_clean)
                        exit_price = ticker['last'] if ticker else trade.get('entry_price', 0)
                        
                        # è®¡ç®—ç›ˆäº
                        entry_price = trade.get('entry_price', 0)
                        quantity = trade.get('quantity', 0)
                        leverage = trade.get('leverage', 10)
                        
                        if entry_price and exit_price and quantity:
                            price_change_pct = (exit_price - entry_price) / entry_price
                            realized_pnl = price_change_pct * entry_price * quantity * leverage
                        else:
                            realized_pnl = 0
                        
                        print(f"[åŒæ­¥] åŒæ­¥æ•°æ®åº“: å…³é—­äº¤æ˜“ #{trade['id']} ({trade['symbol']}) - å¹³ä»“ä»·${exit_price:,.2f}")
                    except Exception as e:
                        print(f"[è­¦å‘Š] è·å–å¹³ä»“ä»·å¤±è´¥: {e}")
                        exit_price = trade.get('entry_price', 0)
                        realized_pnl = 0
                    
                    self.trade_db.close_trade(
                        trade_id=trade['id'],
                        exit_price=exit_price,
                        realized_pnl=realized_pnl,
                        ai_decision={'reason': 'ç³»ç»ŸåŒæ­¥ï¼šå®é™…å·²å¹³ä»“'}
                    )
                return
            
            # å¦‚æœæœ‰æŒä»“ï¼Œå…³é—­ä¸åŒ¹é…çš„äº¤æ˜“
            current_symbol = current_position.get('symbol')
            for trade in open_trades:
                if trade['symbol'] != current_symbol:
                    # è·å–å½“å‰å¸‚åœºä»·æ ¼ä½œä¸ºå¹³ä»“ä»·
                    try:
                        symbol = trade['symbol']
                        # æ¸…ç†symbolæ ¼å¼
                        coin = symbol.split('/')[0]
                        symbol_clean = f"{coin}/USDT:USDT"
                        # ä½¿ç”¨ccxtçš„fetch_tickerè·å–å½“å‰ä»·æ ¼
                        ticker = self.data_fetcher.exchange.fetch_ticker(symbol_clean)
                        exit_price = ticker['last'] if ticker else trade.get('entry_price', 0)
                        
                        # è®¡ç®—ç›ˆäº
                        entry_price = trade.get('entry_price', 0)
                        quantity = trade.get('quantity', 0)
                        leverage = trade.get('leverage', 10)
                        
                        if entry_price and exit_price and quantity:
                            price_change_pct = (exit_price - entry_price) / entry_price
                            realized_pnl = price_change_pct * entry_price * quantity * leverage
                        else:
                            realized_pnl = 0
                        
                        print(f"[åŒæ­¥] åŒæ­¥æ•°æ®åº“: å…³é—­äº¤æ˜“ #{trade['id']} ({trade['symbol']}) - å¹³ä»“ä»·${exit_price:,.2f}")
                    except Exception as e:
                        print(f"[è­¦å‘Š] è·å–å¹³ä»“ä»·å¤±è´¥: {e}")
                        exit_price = trade.get('entry_price', 0)
                        realized_pnl = 0
                    
                    self.trade_db.close_trade(
                        trade_id=trade['id'],
                        exit_price=exit_price,
                        realized_pnl=realized_pnl,
                        ai_decision={'reason': 'ç³»ç»ŸåŒæ­¥ï¼šå¸ç§ä¸åŒ¹é…'}
                    )
        except Exception as e:
            print(f"[è­¦å‘Š] æ•°æ®åº“åŒæ­¥å¤±è´¥: {e}")
    
    def _display_decision(self, decision: Dict):
        """æ˜¾ç¤ºAIå†³ç­–"""
        print(f"\n{'â”€'*70}")
        print("AIå†³ç­–ç»“æœ")
        print(f"{'â”€'*70}")
        
        
        signal = decision.get('signal', 'HOLD')
        confidence = decision.get('confidence', 'LOW')
        symbol = decision.get('symbol', 'N/A')
        
        print(f"å¸ç§: {symbol}")
        print(f"ä¿¡å·: {signal}")
        print(f"ä¿¡å¿ƒåº¦: {confidence}")
        print(f"ç†ç”±: {decision.get('reason', 'N/A')}")
        
        # æŒä»“è¯„ä¼°ï¼ˆæ–°æ ¼å¼ï¼‰
        position_reviews = decision.get('position_reviews', [])
        if position_reviews:
            print(f"\n{'â”€'*70}")
            print("æŒä»“è¯„ä¼°")
            print(f"{'â”€'*70}")
            
            
            for i, review in enumerate(position_reviews, 1):
                symbol = review.get('symbol', 'N/A')
                action = review.get('action', 'N/A')
                confidence = review.get('confidence', 'MEDIUM')
                reason = review.get('reason', '')
                
                if i > 1:
                    print(f"\n{'Â·'*70}")
                
                print(f"\nå¸ç§: {symbol}")
                print(f"å»ºè®®: {action}")
                print(f"ä¿¡å¿ƒåº¦: {confidence}")
                
                # æ˜¾ç¤ºæ­¢æŸæ­¢ç›ˆå»ºè®®ï¼ˆæ”¯æŒå¤šç§å­—æ®µåï¼‰
                suggested_sl = review.get('new_stop_loss') or review.get('suggested_stop_loss') or review.get('stop_loss')
                suggested_tp = review.get('new_take_profit') or review.get('suggested_take_profit') or review.get('take_profit')
                
                if suggested_sl:
                    print(f"æ­¢æŸ: ${suggested_sl:,.2f}")
                if suggested_tp:
                    print(f"æ­¢ç›ˆ: ${suggested_tp:,.2f}")
                if review.get('amount'):
                    print(f"æ•°é‡: {review.get('amount')}")
                
                if reason:
                    print(f"\nåˆ†æ:")
                    # è‡ªåŠ¨æ¢è¡Œæ˜¾ç¤ºåŸå› 
                    for line in reason.split('\n'):
                        if line.strip():
                            print(f"   {line.strip()}")
        
        # å…¼å®¹æ—§æ ¼å¼çš„æŒä»“ç®¡ç†
        pos_mgmt = decision.get('position_management', {})
        if pos_mgmt and self.current_trade_id and not position_reviews:
            action = pos_mgmt.get('current_position_action', 'N/A')
            print(f"\næŒä»“ç®¡ç†:")
            print(f"   å»ºè®®: {action}")
            if pos_mgmt.get('current_position_reason'):
                print(f"   åŸå› : {pos_mgmt.get('current_position_reason')}")
        
        if decision.get('stop_loss'):
            print(f"\næ­¢æŸ: ${decision.get('stop_loss'):,.2f}")
        if decision.get('take_profit'):
            print(f"æ­¢ç›ˆ: ${decision.get('take_profit'):,.2f}")
        if decision.get('amount'):
            print(f"æ•°é‡: {decision.get('amount')}")
        
        if decision.get('think'):
            print(f"\nAIæ€è€ƒè¿‡ç¨‹:")
            # å®Œæ•´æ˜¾ç¤ºAIæ€è€ƒï¼Œä¸æˆªæ–­
            think_text = decision.get('think')
            for line in think_text.split('\n'):
                print(f"   {line}")
        
        print(f"\nTokenæ¶ˆè€—: {decision.get('tokens_used', 0)}")
        
        # æ˜¾ç¤ºå“åº”æ—¶é—´
        response_time = decision.get('response_time', 0)
        if response_time > 0:
            print(f"å“åº”è€—æ—¶: {response_time:.2f}ç§’")
        
        print(f"{'â”€'*70}\n")
    
    def _execute_trade(self, decision: Dict, current_price: float, market_data: Dict, all_market_data: Dict = None):
        """æ‰§è¡Œäº¤æ˜“"""
        signal = decision.get('signal')
        symbol_coin = decision.get('symbol', 'BTC')
        
        # å¤„ç†CLOSE_ALLä¿¡å·ï¼ˆå…³é—­æ‰€æœ‰æŒä»“ï¼‰
        if signal == 'CLOSE_ALL':
            print(f"\n{'='*70}")
            print("ğŸš¨ æ‰§è¡ŒCLOSE_ALLï¼šå…³é—­æ‰€æœ‰æŒä»“")
            print(f"{'='*70}")
            
            # æ¸…é™¤æ‰€æœ‰å¾…ç¡®è®¤çš„å¼€ä»“å†³ç­–
            if self.pending_open_decisions:
                print(f"[åŒæ­¥] æ¸…é™¤æ‰€æœ‰å¾…ç¡®è®¤çš„å¼€ä»“å†³ç­–")
                self.pending_open_decisions.clear()
            
            # è·å–æ‰€æœ‰æŒä»“
            all_positions = []
            try:
                if not TRADING_CONFIG.get('test_mode', True):
                    all_positions = self.data_fetcher.get_all_positions()
            except Exception as e:
                print(f"[è­¦å‘Š] è·å–æŒä»“å¤±è´¥: {e}")
            
            if not all_positions:
                print("[ä¿¡æ¯]  å½“å‰æ— æŒä»“ï¼Œæ— éœ€å¹³ä»“")
                return
            
            # é€ä¸ªå¹³ä»“
            for position in all_positions:
                symbol_full = position.get('symbol')
                symbol_coin_temp = symbol_full.split('/')[0] if '/' in symbol_full else symbol_full
                
                print(f"\nğŸ“¤ å¹³ä»“ {symbol_coin_temp}...")
                
                # è·å–è¯¥å¸ç§çš„ä»·æ ¼
                coin_data = all_market_data.get(symbol_coin_temp, {}) if all_market_data else {}
                close_price = coin_data.get('price', position.get('entry_price', 0))
                
                # æŸ¥æ‰¾äº¤æ˜“è®°å½•å¹¶å¹³ä»“
                try:
                    open_trades = self.trade_db.get_open_trades(symbol_full)
                    if open_trades:
                        for trade in open_trades:
                            realized_pnl = position.get('unrealized_pnl', 0)
                            self.trade_db.close_trade(
                                trade_id=trade['id'],
                                exit_price=close_price,
                                realized_pnl=realized_pnl,
                                ai_decision=decision
                            )
                            print(f"[å®Œæˆ] {symbol_coin} å¹³ä»“å®Œæˆ")
                except Exception as e:
                    print(f"[å¤±è´¥] {symbol_coin} å¹³ä»“å¤±è´¥: {e}")
            
            # æ¸…ç©ºå½“å‰äº¤æ˜“ID
            self.current_trade_id = None
            print(f"\n{'='*70}")
            print("[å®Œæˆ] æ‰€æœ‰æŒä»“å·²å¹³ä»“")
            print(f"{'='*70}\n")
            return
        
        # æ¸…ç†symbolæ ¼å¼ï¼Œåªä¿ç•™å¸ç§åç§°
        if '/' in symbol_coin:
            symbol_coin = symbol_coin.split('/')[0]
        
        symbol_full = f"{symbol_coin}/USDT:USDT"
        
        # å¤„ç†å¹³ä»“ï¼ˆç«‹å³æ‰§è¡Œï¼Œä¸éœ€è¦äºŒæ¬¡ç¡®è®¤ï¼‰
        if signal == 'CLOSE' and self.current_trade_id:
            # æ¸…é™¤è¯¥å¸ç§å¾…ç¡®è®¤çš„å¼€ä»“å†³ç­–
            if symbol_coin in self.pending_open_decisions:
                print(f"[åŒæ­¥] æ¸…é™¤å¾…ç¡®è®¤çš„å¼€ä»“å†³ç­–ï¼š{symbol_coin}")
                del self.pending_open_decisions[symbol_coin]
            # å¹³ä»“å‰å…ˆè®°å½•åˆ°æ•°æ®åº“
            if not TRADING_CONFIG.get('test_mode', True):
                # å®ç›˜æ¨¡å¼ï¼šä»APIè·å–å®é™…ç›ˆäº
                current_position = self.data_fetcher.get_current_position()
                realized_pnl = current_position.get('unrealized_pnl', 0) if current_position else 0
            else:
                # æµ‹è¯•æ¨¡å¼ï¼šè®¡ç®—æ¨¡æ‹Ÿç›ˆäº
                realized_pnl = 0
            
            self.trade_db.close_trade(
                trade_id=self.current_trade_id,
                exit_price=current_price,
                realized_pnl=realized_pnl,
                ai_decision=decision
            )
            self.current_trade_id = None
            return
        
        # å¤„ç†HOLDä¿¡å·ï¼ˆä¸åšä»»ä½•æ“ä½œï¼‰
        if signal == 'HOLD':
            return
        
        # å¤„ç†å¼€ä»“å’ŒåŠ ä»“ï¼ˆéœ€è¦äºŒæ¬¡ç¡®è®¤ï¼‰
        if signal in ['BUY', 'SELL', 'ADD']:
            # å®‰å…¨æœºåˆ¶ï¼šå¼€ä»“éœ€è¦äºŒæ¬¡ç¡®è®¤
            if TRADING_CONFIG.get('require_double_confirmation', True):
                # æ£€æŸ¥è¯¥å¸ç§æ˜¯å¦æœ‰å¾…ç¡®è®¤çš„å†³ç­–
                if symbol_coin in self.pending_open_decisions:
                    last_signal = self.pending_open_decisions[symbol_coin]['signal']
                    last_cycle = self.pending_open_decisions[symbol_coin]['cycle']
                    
                    # åˆ¤æ–­æ˜¯å¦è¿ç»­ä¸¤æ¬¡ç›¸åŒå†³ç­–ï¼ˆå¿…é¡»æ˜¯ä¸åŒå‘¨æœŸï¼‰
                    is_same_decision = (
                        last_signal == signal and
                        self.cycle_count > last_cycle and  # å¿…é¡»æ˜¯ä¸åŒå‘¨æœŸ
                        self.cycle_count - last_cycle <= 2  # å…è®¸é—´éš”1ä¸ªå‘¨æœŸ
                    )
                    
                    if is_same_decision:
                        print(f"[å®Œæˆ] äºŒæ¬¡ç¡®è®¤é€šè¿‡ï¼š{symbol_coin} {signal}ï¼ˆä¸Šæ¬¡å‘¨æœŸ#{last_cycle}ï¼Œæœ¬æ¬¡å‘¨æœŸ#{self.cycle_count}ï¼‰")
                        # ç¡®è®¤é€šè¿‡ï¼Œæ¸…é™¤è®°å½•ï¼Œæ‰§è¡Œäº¤æ˜“
                        del self.pending_open_decisions[symbol_coin]
                    elif self.cycle_count == last_cycle:
                        # åŒä¸€å‘¨æœŸå†…çš„é‡å¤ä¿¡å·ï¼Œè·³è¿‡
                        print(f"[ä¿¡æ¯]  {symbol_coin} {signal} å·²åœ¨æœ¬å‘¨æœŸè®°å½•ï¼Œè·³è¿‡é‡å¤")
                        return
                    else:
                        print(f"[è­¦å‘Š] ä¿¡å·å˜åŒ–ï¼š{symbol_coin} {last_signal} â†’ {signal}ï¼Œé‡æ–°ç­‰å¾…ç¡®è®¤")
                        # æ›´æ–°ä¸ºæ–°å†³ç­–
                        self.pending_open_decisions[symbol_coin] = {
                            'signal': signal,
                            'cycle': self.cycle_count
                        }
                        return
                else:
                    print(f"[è­¦å‘Š] é¦–æ¬¡å¼€ä»“ä¿¡å·ï¼š{symbol_coin} {signal}ï¼Œç­‰å¾…ä¸‹æ¬¡ç¡®è®¤")
                    self.pending_open_decisions[symbol_coin] = {
                        'signal': signal,
                        'cycle': self.cycle_count
                    }
                    return
            
            # è·å–è¯¥å¸ç§çš„é»˜è®¤æ•°é‡
            default_amount = TRADING_CONFIG['amounts'].get(symbol_coin, 0.01)
            actual_amount = decision.get('amount', default_amount)
            
            # è·å–å½“å‰æŒä»“ï¼ˆç”¨äºADDä¿¡å·ï¼‰
            current_position = None
            try:
                if not TRADING_CONFIG.get('test_mode', True):
                    current_position = self.data_fetcher.get_current_position()
            except Exception as e:
                print(f"[è­¦å‘Š] è·å–æŒä»“å¤±è´¥: {e}")
            
            # æ³¨æ„ï¼šä½™é¢æ£€æŸ¥å·²ç§»è‡³_do_execute_tradeä¸­ï¼Œåœ¨å®é™…ä¸‹å•å‰è¿›è¡Œ
            # è¿™æ ·å¯ä»¥è·å–æœ€æ–°çš„ä½™é¢ï¼Œé¿å…åŒå‘¨æœŸå†…å¤šä¸ªæ“ä½œå¯¼è‡´çš„ä½™é¢ä¸ä¸€è‡´
            
            # ADDä¿¡å·è½¬æ¢ä¸ºå®é™…çš„BUY/SELL
            actual_signal = signal
            if signal == 'ADD':
                # æ ¹æ®å½“å‰æŒä»“æ–¹å‘å†³å®š
                if current_position:
                    actual_signal = 'BUY' if current_position.get('side') == 'long' else 'SELL'
                    print(f"[ä¸Šæ¶¨] åŠ ä»“ä¿¡å·: å½“å‰{current_position.get('side')}ä»“ï¼Œæ‰§è¡Œ{actual_signal}")
                else:
                    print(f"[è­¦å‘Š] æ— æŒä»“ï¼ŒADDä¿¡å·æ— æ•ˆ")
                    return
            
            # ç«‹å³å†™å…¥æ•°æ®åº“
            trade_id = self.trade_db.create_trade(
                symbol=symbol_full,
                signal=actual_signal,
                entry_price=current_price,
                quantity=actual_amount,
                leverage=TRADING_CONFIG['leverage'],
                ai_decision=decision,
                market_data=market_data
            )
            
            # å¦‚æœæ˜¯åŠ ä»“ï¼Œä¸æ›´æ–°trade_idï¼ˆä¿æŒåŸæœ‰æŒä»“è®°å½•ï¼‰
            if signal != 'ADD':
                self.current_trade_id = trade_id
            
            print(f"ğŸ“ äº¤æ˜“è®°å½•å·²ä¿å­˜åˆ°æ•°æ®åº“ ID#{trade_id}")
        
        # æ˜¾ç¤ºäº¤æ˜“ä¿¡æ¯
        print(f"{'â”€'*70}")
        mode_text = "ğŸ§ª æµ‹è¯•æ¨¡å¼ - æ¨¡æ‹Ÿäº¤æ˜“" if TRADING_CONFIG.get('test_mode', True) else "ğŸ”´ å®ç›˜äº¤æ˜“"
        print(mode_text)
        print(f"{'â”€'*70}")
        print(f"å¸ç§: {symbol_coin}")
        print(f"ä¿¡å·: {signal}")
        print(f"å½“å‰ä»·: ${current_price:,.2f}")
        
        # åªåœ¨å¼€ä»“æ—¶æ˜¾ç¤ºæ•°é‡ã€æ­¢æŸã€æ­¢ç›ˆ
        if signal in ['BUY', 'SELL', 'ADD']:
            amount = decision.get('amount')
            stop_loss = decision.get('stop_loss')
            take_profit = decision.get('take_profit')
            
            if amount is not None:
                print(f"æ•°é‡: {amount}")
            if stop_loss is not None:
                print(f"æ­¢æŸ: ${stop_loss:,.2f}")
            if take_profit is not None:
                print(f"æ­¢ç›ˆ: ${take_profit:,.2f}")
        if self.current_trade_id:
            print(f"äº¤æ˜“ID: #{self.current_trade_id}")
        print(f"{'â”€'*70}\n")
        
        # å®ç›˜äº¤æ˜“æ‰§è¡Œ
        if not TRADING_CONFIG.get('test_mode', True):
            self._execute_real_trade(signal, symbol_full, decision, current_price)
    
    def _execute_position_reviews(self, reviews: list, all_market_data: Dict, all_positions: list = None):
        """æ‰§è¡ŒæŒä»“ç®¡ç†å»ºè®®"""
        print(f"\n{'='*70}")
        print("æ‰§è¡ŒæŒä»“ç®¡ç†")
        print(f"{'='*70}")
        
        for review in reviews:
            symbol = review.get('symbol', '')
            action = review.get('action', '')
            
            # å¦‚æœæ²¡æœ‰actionå­—æ®µï¼Œé»˜è®¤ä¸ºæ­¢æŸæ­¢ç›ˆç®¡ç†
            if not action:
                action = 'KEEP'  # é»˜è®¤ä¸ºKEEPï¼Œè¿›è¡Œæ­¢æŸæ­¢ç›ˆæ£€æµ‹
            
            # è·³è¿‡N/Aæˆ–HOLDçš„action
            if action.upper() in ['N/A', 'HOLD']:
                print(f"\nâ­ï¸  è·³è¿‡ {symbol}: æ— éœ€æ“ä½œ")
                continue
            
            # æ¸…ç†å¹¶æå–å¸ç§åç§°
            if '/' in symbol:
                coin = symbol.split('/')[0]
            else:
                coin = symbol
            
            print(f"\nå¤„ç† {symbol}:")
            print(f"å»ºè®®: {action}")
            
            if action == 'CLOSE':
                # å¹³ä»“ï¼ˆç«‹å³æ‰§è¡Œï¼Œä¸éœ€è¦äºŒæ¬¡ç¡®è®¤ï¼‰
                print("ğŸ“¤ æ‰§è¡Œå¹³ä»“...")
                
                # ç‰¹æ®Šå¤„ç†ï¼šALLè¡¨ç¤ºå…³é—­æ‰€æœ‰æŒä»“
                if symbol.upper() == 'ALL':
                    if not all_positions or len(all_positions) == 0:
                        print("[ä¿¡æ¯]  å½“å‰æ— æŒä»“ï¼Œæ— éœ€å¹³ä»“")
                        continue
                    
                    print(f"ğŸ”´ å…³é—­æ‰€æœ‰æŒä»“ï¼ˆå…±{len(all_positions)}ä¸ªï¼‰")
                    for pos in all_positions:
                        try:
                            pos_symbol = pos.get('symbol')
                            pos_coin = pos_symbol.split('/')[0] if '/' in pos_symbol else pos_symbol
                            symbol_full = f"{pos_coin}/USDT:USDT"
                            
                            amount = pos.get('size', 0)
                            side = pos.get('side')
                            close_side = 'sell' if side == 'long' else 'buy'
                            
                            trade_mode = self._get_position_trade_mode(symbol_full)
                            
                            print(f"\n  å¹³ä»“ {pos_symbol}: {amount} @ {close_side}")
                            order = self.data_fetcher.exchange.create_order(
                                symbol=symbol_full,
                                type='market',
                                side=close_side,
                                amount=amount,
                                params={
                                    'tdMode': trade_mode,
                                    'posSide': side,
                                    'reduceOnly': True
                                }
                            )
                            print(f"  [å®Œæˆ] {pos_symbol} å¹³ä»“æˆåŠŸ")
                        except Exception as e:
                            print(f"  [å¤±è´¥] {pos_symbol} å¹³ä»“å¤±è´¥: {e}")
                    continue
                
                # å•ä¸ªå¸ç§å¹³ä»“
                try:
                    symbol_full = f"{coin}/USDT:USDT"
                    inst_id = symbol_full.split(':')[0].replace('/', '-') + '-SWAP'
                    
                    # è·å–æŒ‡å®šå¸ç§çš„æŒä»“ä¿¡æ¯
                    position = self.data_fetcher.get_position_by_symbol(symbol_full)
                    if not position:
                        print(f"[è­¦å‘Š] æœªæ‰¾åˆ°{symbol}æŒä»“")
                        continue
                    
                    # ä½¿ç”¨sizeå­—æ®µï¼ˆåˆçº¦æ•°é‡ï¼‰ï¼Œè€Œä¸æ˜¯btc_amount
                    amount = position.get('size', 0)
                    side = position.get('side')  # 'long' or 'short'
                    
                    # å¹³ä»“æ–¹å‘ä¸å¼€ä»“ç›¸å
                    close_side = 'sell' if side == 'long' else 'buy'
                    pos_side = side
                    
                    # æ™ºèƒ½è¯†åˆ«æŒä»“çš„äº¤æ˜“æ¨¡å¼
                    trade_mode = self._get_position_trade_mode(symbol_full)
                    print(f"ğŸ“‹ æ£€æµ‹åˆ°æŒä»“æ¨¡å¼: {trade_mode}")
                    
                    # æ‰§è¡Œå¹³ä»“
                    order = self.data_fetcher.exchange.create_order(
                        symbol=symbol_full,
                        type='market',
                        side=close_side,
                        amount=amount,
                        params={
                            'tdMode': trade_mode,  # ä½¿ç”¨æŒä»“çš„äº¤æ˜“æ¨¡å¼
                            'posSide': pos_side,
                            'reduceOnly': True  # åªå‡ä»“
                        }
                    )
                    
                    print(f"[å®Œæˆ] {symbol} å¹³ä»“æˆåŠŸ")
                    
                    # è®°å½•åˆ°MCPè®°å¿†ç³»ç»Ÿ
                    try:
                        if hasattr(self.ai_trader, 'mcp_memory'):
                            # è·å–æŒä»“ä¿¡æ¯è®¡ç®—ç›ˆäº
                            pnl_pct = 0
                            if position:
                                unrealized_pnl = position.get('unrealized_pnl', 0)
                                entry_price = position.get('entry_price', 0)
                                quantity = position.get('quantity', 0)
                                if entry_price > 0 and quantity > 0:
                                    pnl_pct = (unrealized_pnl / (entry_price * quantity)) * 100
                            
                            trade_info = {
                                'symbol': coin,
                                'pnl_percent': pnl_pct,
                                'market_state': 'unknown',  # å¯ä»¥ä»AIå†³ç­–ä¸­æå–
                                'strategy': 'unknown',
                                'close_reason': review.get('reason', 'AIå†³ç­–å¹³ä»“')
                            }
                            
                            if pnl_pct > 0:
                                self.ai_trader.mcp_memory.record_successful_trade(trade_info)
                                print(f"ğŸ§  å·²è®°å½•æˆåŠŸäº¤æ˜“ç»éªŒ")
                            else:
                                self.ai_trader.mcp_memory.record_failed_trade(trade_info)
                                print(f"ğŸ§  å·²è®°å½•å¤±è´¥äº¤æ˜“æ•™è®­")
                            
                            # ä¿å­˜äº¤æ˜“æ—¥å¿—
                            if hasattr(self.ai_trader, 'mcp_filesystem'):
                                log_content = f"{coin} å¹³ä»“ - ç›ˆäº: {pnl_pct:+.2f}% - åŸå› : {review.get('reason', 'AIå†³ç­–')}"
                                self.ai_trader.mcp_filesystem.save_trade_log(log_content)
                    except Exception as e:
                        print(f"[è­¦å‘Š] MCPè®°å½•å¤±è´¥: {e}")
                    
                    # å–æ¶ˆæ­¢ç›ˆæ­¢æŸè®¢å•
                    try:
                        algo_orders = self.data_fetcher.get_algo_orders(symbol_full)
                        for order in algo_orders:
                            order_id = order.get('algoId')
                            if order_id:
                                self.data_fetcher.exchange.private_post_trade_cancel_algos([{
                                    'algoId': order_id,
                                    'instId': inst_id
                                }])
                    except:
                        pass
                        
                except Exception as e:
                    print(f"[å¤±è´¥] {symbol} å¹³ä»“å¤±è´¥: {e}")
                    import traceback
                    traceback.print_exc()
            
            elif action in ['KEEP', 'ADJUST_SL', 'ADJUST_TP']:
                # KEEPæˆ–è°ƒæ•´æ­¢æŸæ­¢ç›ˆï¼ˆç«‹å³æ‰§è¡Œï¼Œä¸éœ€è¦äºŒæ¬¡ç¡®è®¤ï¼‰
                # æ”¯æŒå¤šç§å­—æ®µå
                new_sl = review.get('new_stop_loss') or review.get('suggested_stop_loss') or review.get('stop_loss')
                new_tp = review.get('new_take_profit') or review.get('suggested_take_profit') or review.get('take_profit')
                
                # è·å–å½“å‰æŒä»“çš„æ­¢æŸæ­¢ç›ˆ
                symbol_full = f"{coin}/USDT:USDT"
                current_position = self.data_fetcher.get_position_by_symbol(symbol_full)
                current_sl = current_position.get('stop_loss') if current_position else None
                current_tp = current_position.get('take_profit') if current_position else None
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒæ•´
                need_adjust_sl = new_sl and (not current_sl or abs(new_sl - current_sl) > 0.01)
                need_adjust_tp = new_tp and (not current_tp or abs(new_tp - current_tp) > 0.01)
                
                if need_adjust_sl:
                    current_sl_str = f"${current_sl:.2f}" if current_sl else "æœªè®¾ç½®"
                    print(f"ğŸ“‹ æ£€æµ‹åˆ°æ­¢æŸå˜åŒ–: å½“å‰{current_sl_str} â†’ å»ºè®®${new_sl:.2f}")
                if need_adjust_tp:
                    current_tp_str = f"${current_tp:.2f}" if current_tp else "æœªè®¾ç½®"
                    print(f"ğŸ“‹ æ£€æµ‹åˆ°æ­¢ç›ˆå˜åŒ–: å½“å‰{current_tp_str} â†’ å»ºè®®${new_tp:.2f}")
                
                if need_adjust_sl or need_adjust_tp:
                    print("ğŸ”§ è‡ªåŠ¨è°ƒæ•´æ­¢æŸæ­¢ç›ˆ...")
                else:
                    print("[å®Œæˆ] ä¿æŒæŒä»“ï¼Œæ­¢æŸæ­¢ç›ˆæ— éœ€è°ƒæ•´")
                    continue
                
                if True:  # ç»§ç»­æ‰§è¡Œè°ƒæ•´é€»è¾‘
                    try:
                        symbol_full = f"{coin}/USDT:USDT"
                        inst_id = symbol_full.split(':')[0].replace('/', '-') + '-SWAP'
                        
                        # 1. åªå–æ¶ˆéœ€è¦è°ƒæ•´çš„è®¢å•
                        print("  å–æ¶ˆéœ€è¦è°ƒæ•´çš„è®¢å•...")
                        try:
                            # è·å–å½“å‰ç­–ç•¥è®¢å•
                            algo_orders = self.data_fetcher.get_algo_orders(symbol_full)
                            for order in algo_orders:
                                order_id = order.get('algoId')
                                if not order_id:
                                    continue
                                
                                # åˆ¤æ–­æ˜¯æ­¢æŸè¿˜æ˜¯æ­¢ç›ˆè®¢å•
                                has_sl = order.get('slTriggerPx')
                                has_tp = order.get('tpTriggerPx')
                                
                                # åªå–æ¶ˆéœ€è¦è°ƒæ•´çš„è®¢å•ï¼ˆä½¿ç”¨need_adjustæ ‡å¿—ï¼‰
                                should_cancel = False
                                if need_adjust_sl and has_sl:
                                    should_cancel = True
                                    print(f"  å–æ¶ˆæ—§æ­¢æŸè®¢å•...")
                                if need_adjust_tp and has_tp:
                                    should_cancel = True
                                    print(f"  å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•...")
                                
                                if should_cancel:
                                    cancel_result = self.data_fetcher.exchange.private_post_trade_cancel_algos([{
                                        'algoId': order_id,
                                        'instId': inst_id
                                    }])
                                    if cancel_result.get('code') == '0':
                                        print(f"  âœ“ å·²å–æ¶ˆè®¢å• {order_id}")
                                    else:
                                        print(f"  [è­¦å‘Š] å–æ¶ˆè®¢å•å¤±è´¥: {cancel_result.get('msg')}")
                        except Exception as e:
                            print(f"  [è­¦å‘Š] å–æ¶ˆè®¢å•å¤±è´¥: {e}")
                        
                        # 2. è·å–æŒ‡å®šå¸ç§çš„æŒä»“ä¿¡æ¯
                        position = self.data_fetcher.get_position_by_symbol(symbol_full)
                        if not position:
                            print(f"  [è­¦å‘Š] æœªæ‰¾åˆ°{symbol}æŒä»“")
                            continue
                        
                        # ä½¿ç”¨sizeå­—æ®µï¼ˆåˆçº¦æ•°é‡ï¼‰ï¼Œè€Œä¸æ˜¯btc_amount
                        amount = position.get('size', 0)
                        side = position.get('side')  # 'long' or 'short'
                        pos_side = side
                        close_side = 'sell' if side == 'long' else 'buy'
                        
                        # æ™ºèƒ½è¯†åˆ«æŒä»“çš„äº¤æ˜“æ¨¡å¼
                        trade_mode = self._get_position_trade_mode(symbol_full)
                        print(f"  ğŸ“‹ æ£€æµ‹åˆ°æŒä»“æ¨¡å¼: {trade_mode}")
                        
                        # ä¿®æ­£æ•°é‡ç²¾åº¦
                        min_amount = TRADING_CONFIG.get('min_amounts', {}).get(coin, 0.01)
                        if coin in ['ETH', 'SOL']:
                            amount = round(amount / 0.1) * 0.1  # 0.1çš„å€æ•°
                            amount = max(amount, 0.1)  # ç¡®ä¿è‡³å°‘0.1
                        elif coin == 'BTC':
                            amount = round(amount / 0.01) * 0.01  # 0.01çš„å€æ•°
                            amount = max(amount, 0.01)  # ç¡®ä¿è‡³å°‘0.01
                        elif coin == 'XRP':
                            amount = round(amount / 0.1) * 0.1  # 0.1çš„å€æ•°ï¼ˆ1å¼ åˆçº¦=100 XRPï¼‰
                            amount = max(amount, 0.1)  # ç¡®ä¿è‡³å°‘0.1å¼ 
                        elif coin in ['DOGE', 'BNB']:
                            amount = int(amount)  # æ•´æ•°
                            amount = max(amount, 1)  # ç¡®ä¿è‡³å°‘1
                        
                        # 3. è®¾ç½®æ–°çš„æ­¢æŸæ­¢ç›ˆï¼ˆåªè®¾ç½®éœ€è¦è°ƒæ•´çš„ï¼‰
                        success_count = 0
                        
                        # è®¾ç½®æ­¢æŸï¼ˆåªæœ‰éœ€è¦è°ƒæ•´æ—¶æ‰è®¾ç½®ï¼‰
                        if need_adjust_sl and new_sl:
                            try:
                                sl_params = {
                                    'instId': inst_id,
                                    'tdMode': trade_mode,  # ä½¿ç”¨æŒä»“çš„äº¤æ˜“æ¨¡å¼
                                    'posSide': pos_side,
                                    'side': close_side,
                                    'ordType': 'conditional',
                                    'sz': str(amount),
                                    'slTriggerPx': str(new_sl),
                                    'slOrdPx': '-1',
                                }
                                print(f"  è®¾ç½®æ–°æ­¢æŸ: ${new_sl:,.2f}")
                                result = self.data_fetcher.exchange.private_post_trade_order_algo(sl_params)
                                
                                if result.get('code') == '0':
                                    print(f"  [å®Œæˆ] æ­¢æŸè®¾ç½®æˆåŠŸ")
                                    success_count += 1
                                else:
                                    print(f"  [å¤±è´¥] æ­¢æŸè®¾ç½®å¤±è´¥: {result.get('msg')}")
                            except Exception as e:
                                print(f"  [å¤±è´¥] æ­¢æŸè®¾ç½®å¤±è´¥: {e}")
                        
                        # è®¾ç½®æ­¢ç›ˆï¼ˆåªæœ‰éœ€è¦è°ƒæ•´æ—¶æ‰è®¾ç½®ï¼‰
                        if need_adjust_tp and new_tp:
                            try:
                                tp_params = {
                                    'instId': inst_id,
                                    'tdMode': trade_mode,  # ä½¿ç”¨æŒä»“çš„äº¤æ˜“æ¨¡å¼
                                    'posSide': pos_side,
                                    'side': close_side,
                                    'ordType': 'conditional',
                                    'sz': str(amount),
                                    'tpTriggerPx': str(new_tp),
                                    'tpOrdPx': '-1',
                                }
                                print(f"  è®¾ç½®æ–°æ­¢ç›ˆ: ${new_tp:,.2f}")
                                result = self.data_fetcher.exchange.private_post_trade_order_algo(tp_params)
                                
                                if result.get('code') == '0':
                                    print(f"  [å®Œæˆ] æ­¢ç›ˆè®¾ç½®æˆåŠŸ")
                                    success_count += 1
                                else:
                                    print(f"  [å¤±è´¥] æ­¢ç›ˆè®¾ç½®å¤±è´¥: {result.get('msg')}")
                            except Exception as e:
                                print(f"  [å¤±è´¥] æ­¢ç›ˆè®¾ç½®å¤±è´¥: {e}")
                        
                        # æ€»ç»“
                        total_to_set = (1 if need_adjust_sl else 0) + (1 if need_adjust_tp else 0)
                        if success_count == total_to_set:
                            print(f"[å®Œæˆ] {symbol} æ­¢æŸæ­¢ç›ˆè°ƒæ•´æˆåŠŸ")
                        elif success_count > 0:
                            print(f"[è­¦å‘Š] {symbol} éƒ¨åˆ†è°ƒæ•´æˆåŠŸ ({success_count}/{total_to_set})")
                        else:
                            print(f"[å¤±è´¥] {symbol} è°ƒæ•´å¤±è´¥")
                        
                    except Exception as e:
                        print(f"[å¤±è´¥] {symbol} è°ƒæ•´å¤±è´¥: {e}")
                        import traceback
                        traceback.print_exc()
            
            elif action in ['BUY', 'SELL', 'ADD']:
                # position_reviewsä¸­çš„å¼€ä»“/åŠ ä»“ä¿¡å·ï¼ˆéœ€è¦äºŒæ¬¡ç¡®è®¤ï¼‰
                # åˆ¤æ–­æ˜¯å¦ä¸ºåŠ ä»“ï¼ˆå·²æœ‰æŒä»“ï¼‰
                is_add_position = False
                if action in ['BUY', 'SELL']:
                    # æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯¥å¸ç§çš„æŒä»“
                    for pos in (all_positions or []):
                        if pos.get('symbol') == coin:
                            is_add_position = True
                            break
                
                action_text = 'åŠ ä»“' if (action == 'ADD' or is_add_position) else 'å¼€ä»“'
                print(f"[æ•°æ®] æ£€æµ‹åˆ°{action_text}ä¿¡å·: {coin} {action}")
                
                # æ„é€ å†³ç­–å¯¹è±¡
                # ä¼˜å…ˆä½¿ç”¨AIæŒ‡å®šçš„amountï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼
                default_amount = TRADING_CONFIG['amounts'].get(coin, 0.01)
                ai_amount = review.get('amount')
                
                open_decision = {
                    'signal': action,
                    'symbol': coin,
                    'confidence': review.get('confidence', 'MEDIUM'),
                    'reason': review.get('reason', ''),
                    'stop_loss': review.get('new_stop_loss'),
                    'take_profit': review.get('new_take_profit'),
                    'amount': ai_amount if ai_amount else default_amount,
                    'think': review.get('reason', '')
                }
                
                if ai_amount:
                    print(f"   AIæŒ‡å®šæ•°é‡: {ai_amount}")
                
                # è·å–å¸‚åœºæ•°æ®
                coin_data = all_market_data.get(coin, {})
                current_price = coin_data.get('price', 0)
                
                if current_price > 0:
                    # è°ƒç”¨_execute_tradeï¼Œä¼šè‡ªåŠ¨åº”ç”¨äºŒæ¬¡ç¡®è®¤æœºåˆ¶
                    self._execute_trade(open_decision, current_price, coin_data)
                else:
                    print(f"[è­¦å‘Š] æ— æ³•è·å–{coin}ä»·æ ¼ï¼Œè·³è¿‡å¼€ä»“")
        
        print(f"{'='*70}\n")
    
    def _execute_real_trade(self, signal: str, symbol: str, decision: Dict, current_price: float):
        """æ‰§è¡Œå®ç›˜äº¤æ˜“"""
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                self._do_execute_trade(signal, symbol, decision, current_price)
                return
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"[è­¦å‘Š] äº¤æ˜“å¤±è´¥ï¼ˆå°è¯• {attempt + 1}/{max_retries}ï¼‰ï¼Œ{retry_delay}ç§’åé‡è¯•...")
                    print(f"   é”™è¯¯: {str(e)[:100]}")
                    time.sleep(retry_delay)
                else:
                    print(f"[å¤±è´¥] äº¤æ˜“æœ€ç»ˆå¤±è´¥: {e}")
                    import traceback
                    traceback.print_exc()
    
    def _do_execute_trade(self, signal: str, symbol: str, decision: Dict, current_price: float):
        """å®é™…æ‰§è¡Œäº¤æ˜“ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰"""
        try:
            if signal == 'CLOSE':
                # å¹³ä»“
                print("ğŸ“¤ æ‰§è¡Œå¹³ä»“...")
                
                # è·å–å½“å‰æŒä»“ä¿¡æ¯
                position = self.data_fetcher.get_position_by_symbol(symbol)
                if not position:
                    print(f"[è­¦å‘Š] æœªæ‰¾åˆ°{symbol}æŒä»“")
                    return
                
                # è·å–æŒä»“ä¿¡æ¯
                amount = position.get('size', 0)
                side = position.get('side')  # 'long' or 'short'
                
                if amount <= 0:
                    print(f"[è­¦å‘Š] æŒä»“æ•°é‡ä¸º0ï¼Œæ— éœ€å¹³ä»“")
                    return
                
                # å¹³ä»“æ–¹å‘ï¼šå¤šå•å¹³ä»“ç”¨sellï¼Œç©ºå•å¹³ä»“ç”¨buy
                close_side = 'sell' if side == 'long' else 'buy'
                
                # è·å–äº¤æ˜“æ¨¡å¼
                trade_mode = self._get_position_trade_mode(symbol)
                
                print(f"å¹³ä»“å‚æ•°: {symbol} | æ–¹å‘: {close_side} | æ•°é‡: {amount} | æ¨¡å¼: {trade_mode} | æŒä»“æ–¹å‘: {side}")
                
                # æ‰§è¡Œå¹³ä»“ - OKXæ°¸ç»­åˆçº¦å¿…é¡»æŒ‡å®šposSide
                params = {
                    'tdMode': trade_mode,
                    'posSide': side,  # æŒä»“æ–¹å‘ï¼ˆlongæˆ–shortï¼‰
                    'reduceOnly': True  # åªå‡ä»“ï¼Œä¸å¼€æ–°ä»“
                }
                
                order = self.data_fetcher.exchange.create_order(
                    symbol=symbol,
                    type='market',
                    side=close_side,
                    amount=amount,
                    params=params
                )
                
                print(f"[å®Œæˆ] å¹³ä»“æˆåŠŸ: {order.get('id', 'N/A')}")
                return
            
            # å¼€ä»“
            side = 'buy' if signal == 'BUY' else 'sell'
            coin = symbol.split('/')[0]
            
            # è·å–æ•°é‡ï¼Œç¡®ä¿ä¸ä½äºæœ€å°å€¼
            ai_amount = decision.get('amount', 0)
            default_amount = TRADING_CONFIG['amounts'].get(coin, 0.01)
            min_amount = TRADING_CONFIG.get('min_amounts', {}).get(coin, 0.01)
            
            print(f"[æ•°é‡å†³ç­–] AIå»ºè®®: {ai_amount}, é»˜è®¤: {default_amount}, æœ€å°: {min_amount}")
            
            # ä½¿ç”¨AIå»ºè®®çš„æ•°é‡ï¼Œä½†ä¸èƒ½ä½äºæœ€å°å€¼
            if ai_amount and ai_amount > 0:
                amount = max(ai_amount, min_amount)
            else:
                amount = default_amount
            
            # [è­¦å‘Š] å…¨ä»“æ¨¡å¼å®‰å…¨ç³»æ•°ï¼šé€‚å½“å‡å°‘æ•°é‡ï¼Œç¡®ä¿æœ‰ç¼“å†²
            # å…¨ä»“æ¨¡å¼ä¿è¯é‡‘å…±äº«ï¼Œåˆ©ç”¨ç‡æ›´é«˜ï¼Œä½†ä»éœ€ä¿å®ˆ
            # å»ºè®®ä½¿ç”¨AIå»ºè®®æ•°é‡çš„70%ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿç¼“å†²
            amount = amount * 0.7
            # ç¡®ä¿ä¸ä½äºæœ€å°å€¼
            amount = max(amount, min_amount)
            
            # æ ¹æ®å¸ç§ç±»å‹æ ¼å¼åŒ–æ•°é‡
            if coin in ['BTC', 'ETH', 'SOL']:
                # å°æ•°å¸ç§ï¼Œä¿ç•™2ä½å°æ•°
                amount = round(amount, 2)
            elif coin == 'XRP':
                # XRP: 1å¼ åˆçº¦=100 XRPï¼Œamountæ˜¯å¼ æ•°ï¼Œ0.1å¼ =10 XRP
                # ä¿ç•™1ä½å°æ•°ï¼Œ0.1çš„å€æ•°
                amount = round(amount / 0.1) * 0.1
                amount = max(amount, 0.1)  # æœ€å°0.1å¼ 
            elif coin in ['DOGE', 'BNB']:
                # æ•´æ•°å¸ç§ï¼Œå‘ä¸‹å–æ•´
                amount = int(amount)
            
            print(f"[è­¦å‘Š] å…¨ä»“æ¨¡å¼å®‰å…¨è°ƒæ•´: ä½¿ç”¨70%æ•°é‡ = {amount}")
            
            stop_loss = decision.get('stop_loss')
            take_profit = decision.get('take_profit')
            
            # åœ¨ä¸‹å•å‰è·å–æœ€æ–°ä½™é¢å’ŒæŒä»“ï¼Œç”¨äºæ—¥å¿—è¾“å‡º
            try:
                balance = self.data_fetcher.exchange.fetch_balance()
                available_usdt = balance['USDT']['free']
                total_usdt = balance['USDT']['total']
                used_usdt = balance['USDT']['used']
                required_margin = (current_price * 1.05 * amount) / TRADING_CONFIG['leverage']
                
                # è·å–å½“å‰æŒä»“
                positions = self.data_fetcher.exchange.fetch_positions()
                active_positions = [p for p in positions if p.get('contracts', 0) > 0]
                
                print(f"[é‡‘é¢] å®æ—¶ä½™é¢æ£€æŸ¥:")
                print(f"   æ€»ä½™é¢: ${total_usdt:.2f}")
                print(f"   å·²ç”¨: ${used_usdt:.2f}")
                print(f"   å¯ç”¨: ${available_usdt:.2f}")
                print(f"   æœ¬æ¬¡éœ€è¦: ${required_margin:.2f}")
                print(f"   å½“å‰æŒä»“æ•°: {len(active_positions)}")
                
                # å¦‚æœå¯ç”¨ä½™é¢ä¸è¶³æˆ–æŒä»“è¿‡å¤šï¼Œç»™å‡ºè­¦å‘Š
                if available_usdt < required_margin * 3:  # éœ€è¦3å€ç¼“å†²ï¼ˆå…¨ä»“æ¨¡å¼é£æ§æ›´ä¸¥ï¼‰
                    print(f"[è­¦å‘Š] è­¦å‘Š: å¯ç”¨ä½™é¢å¯èƒ½ä¸è¶³ï¼ˆéœ€è¦3å€ç¼“å†²ï¼‰ï¼")
                    print(f"   å½“å‰å¯ç”¨: ${available_usdt:.2f}")
                    print(f"   éœ€è¦ç¼“å†²: ${required_margin * 3:.2f}")
                    print(f"   å»ºè®®: å…ˆå¹³æ‰ä¸€äº›æŒä»“é‡Šæ”¾ä¿è¯é‡‘ï¼Œæˆ–å……å€¼æ›´å¤šèµ„é‡‘")
                    # ä¸æ‰§è¡Œå¼€ä»“
                    return
                
                # å¦‚æœæŒä»“è¿‡å¤šï¼Œä¹Ÿç»™å‡ºè­¦å‘Š
                if len(active_positions) >= 3:
                    print(f"[è­¦å‘Š] è­¦å‘Š: å½“å‰æŒä»“æ•°({len(active_positions)})å·²è¾¾ä¸Šé™ï¼")
                    print(f"   å»ºè®®: å…ˆå¹³æ‰ä¸€äº›æŒä»“å†å¼€æ–°ä»“")
                    # ä¸æ‰§è¡Œå¼€ä»“
                    return
                    
            except Exception as e:
                print(f"[è­¦å‘Š] è·å–ä½™é¢å¤±è´¥: {e}")
            
            print(f"ğŸ“¤ æ‰§è¡Œå¼€ä»“: {side.upper()} {amount} {symbol}")
            if ai_amount and ai_amount > 0 and ai_amount < min_amount:
                print(f"[è­¦å‘Š] AIå»ºè®®æ•°é‡{ai_amount}ä½äºæœ€å°å€¼{min_amount}ï¼Œå·²è°ƒæ•´ä¸º{amount}")
            elif ai_amount and ai_amount > 0:
                print(f"âœ“ ä½¿ç”¨AIå»ºè®®æ•°é‡: {ai_amount}")
            
            # 1. è®¾ç½®æ æ†
            leverage = TRADING_CONFIG.get('leverage', 10)
            try:
                self.data_fetcher.exchange.set_leverage(
                    leverage=leverage,
                    symbol=symbol,
                    params={'mgnMode': 'cross', 'posSide': 'long' if side == 'buy' else 'short'}
                )
                print(f"[å®Œæˆ] æ æ†è®¾ç½®ä¸º {leverage}x")
            except Exception as e:
                print(f"[è­¦å‘Š] æ æ†è®¾ç½®å¤±è´¥ï¼ˆå¯èƒ½å·²è®¾ç½®ï¼‰: {str(e)[:50]}")
            
            # 2. ä¸‹å¸‚ä»·å•å¼€ä»“
            print("â³ å‘é€è®¢å•åˆ°OKX...")
            print(f"ğŸ“‹ è®¢å•å‚æ•°: symbol={symbol}, side={side}, amount={amount}")
            self.data_fetcher.exchange.options['timeout'] = 60000  # 60ç§’è¶…æ—¶
            
            # OKXæ°¸ç»­åˆçº¦å‚æ•°
            pos_side = 'long' if side == 'buy' else 'short'
            print(f"ğŸ“‹ OKXå‚æ•°: tdMode=cross, posSide={pos_side}")
            
            order = self.data_fetcher.exchange.create_market_order(
                symbol=symbol,
                side=side,
                amount=amount,
                params={
                    'tdMode': 'cross',      # å…¨ä»“æ¨¡å¼ï¼ˆä¿è¯é‡‘å…±äº«ï¼‰
                    'posSide': pos_side,    # æŒä»“æ–¹å‘
                    'ccy': 'USDT',          # ä¿è¯é‡‘å¸ç§
                }
            )
            
            print(f"[å®Œæˆ] å¼€ä»“æˆåŠŸ: è®¢å•ID {order['id']}")
            
            # 2. å…ˆå–æ¶ˆè¯¥å¸ç§çš„æ‰€æœ‰æ—§æ­¢ç›ˆæ­¢æŸè®¢å•ï¼ˆé¿å…ç´¯ç§¯ï¼‰
            inst_id = symbol.split(':')[0].replace('/', '-') + '-SWAP'
            close_side = 'sell' if side == 'buy' else 'buy'
            
            print("ğŸ”§ æ¸…ç†æ—§æ­¢ç›ˆæ­¢æŸè®¢å•...")
            try:
                algo_orders = self.data_fetcher.get_algo_orders(symbol)
                for order in algo_orders:
                    order_id = order.get('algoId')
                    if order_id:
                        cancel_result = self.data_fetcher.exchange.private_post_trade_cancel_algos([{
                            'algoId': order_id,
                            'instId': inst_id
                        }])
                        if cancel_result.get('code') == '0':
                            print(f"  âœ“ å·²å–æ¶ˆæ—§è®¢å• {order_id}")
            except Exception as e:
                print(f"  [è­¦å‘Š] æ¸…ç†æ—§è®¢å•å¤±è´¥: {e}")
            
            # 3. è®¾ç½®æ–°çš„æ­¢æŸæ­¢ç›ˆ
            
            # éªŒè¯æ­¢æŸæ­¢ç›ˆä»·æ ¼çš„åˆç†æ€§
            if stop_loss or take_profit:
                print(f"\nğŸ“‹ éªŒè¯æ­¢æŸæ­¢ç›ˆä»·æ ¼...")
                print(f"   æŒä»“æ–¹å‘: {pos_side}")
                print(f"   å½“å‰ä»·æ ¼: ${current_price:,.2f}")
                if stop_loss:
                    print(f"   æ­¢æŸä»·æ ¼: ${stop_loss:,.2f}")
                if take_profit:
                    print(f"   æ­¢ç›ˆä»·æ ¼: ${take_profit:,.2f}")
                
                # æ ¹æ®æŒä»“æ–¹å‘éªŒè¯ä»·æ ¼
                if pos_side == 'long':
                    # å¤šå•ï¼šæ­¢æŸåº”ä½äºå½“å‰ä»·ï¼Œæ­¢ç›ˆåº”é«˜äºå½“å‰ä»·
                    if stop_loss and stop_loss >= current_price:
                        print(f"[è­¦å‘Š] å¤šå•æ­¢æŸä»·æ ¼é”™è¯¯ï¼æ­¢æŸ${stop_loss:.2f} >= å½“å‰ä»·${current_price:.2f}")
                        print(f"   è‡ªåŠ¨è°ƒæ•´ä¸ºå½“å‰ä»·çš„98%: ${current_price * 0.98:.2f}")
                        stop_loss = current_price * 0.98
                    if take_profit and take_profit <= current_price:
                        print(f"[è­¦å‘Š] å¤šå•æ­¢ç›ˆä»·æ ¼é”™è¯¯ï¼æ­¢ç›ˆ${take_profit:.2f} <= å½“å‰ä»·${current_price:.2f}")
                        print(f"   è‡ªåŠ¨è°ƒæ•´ä¸ºå½“å‰ä»·çš„105%: ${current_price * 1.05:.2f}")
                        take_profit = current_price * 1.05
                else:  # short
                    # ç©ºå•ï¼šæ­¢æŸåº”é«˜äºå½“å‰ä»·ï¼Œæ­¢ç›ˆåº”ä½äºå½“å‰ä»·
                    if stop_loss and stop_loss <= current_price:
                        print(f"[è­¦å‘Š] ç©ºå•æ­¢æŸä»·æ ¼é”™è¯¯ï¼æ­¢æŸ${stop_loss:.2f} <= å½“å‰ä»·${current_price:.2f}")
                        print(f"   è‡ªåŠ¨è°ƒæ•´ä¸ºå½“å‰ä»·çš„102%: ${current_price * 1.02:.2f}")
                        stop_loss = current_price * 1.02
                    if take_profit and take_profit >= current_price:
                        print(f"[è­¦å‘Š] ç©ºå•æ­¢ç›ˆä»·æ ¼é”™è¯¯ï¼æ­¢ç›ˆ${take_profit:.2f} >= å½“å‰ä»·${current_price:.2f}")
                        print(f"   è‡ªåŠ¨è°ƒæ•´ä¸ºå½“å‰ä»·çš„95%: ${current_price * 0.95:.2f}")
                        take_profit = current_price * 0.95
            
            # è®¾ç½®æ­¢æŸï¼ˆä½¿ç”¨OKXçš„æ­¢ç›ˆæ­¢æŸAPIï¼‰
            if stop_loss:
                try:
                    print(f"\nğŸ›¡ï¸ è®¾ç½®æ­¢æŸ: ${stop_loss:,.2f}")
                    # ä½¿ç”¨OKXçš„æ¡ä»¶å•APIè®¾ç½®æ­¢æŸ
                    sl_order = self.data_fetcher.exchange.create_order(
                        symbol=symbol,
                        type='market',
                        side=close_side,
                        amount=amount,
                        params={
                            'tdMode': 'cross',
                            'posSide': pos_side,
                            'ordType': 'conditional',
                            'slTriggerPx': str(stop_loss),
                            'slOrdPx': '-1',  # -1è¡¨ç¤ºå¸‚ä»·
                            'reduceOnly': True
                        }
                    )
                    print(f"[å®Œæˆ] æ­¢æŸè®¾ç½®æˆåŠŸ: ${stop_loss:,.2f}, è®¢å•ID: {sl_order.get('id', 'N/A')}")
                except Exception as e:
                    print(f"[è­¦å‘Š] æ­¢æŸè®¾ç½®å¤±è´¥: {e}")
                    import traceback
                    traceback.print_exc()
            
            # è®¾ç½®æ­¢ç›ˆ
            if take_profit:
                try:
                    print(f"\n[ç›®æ ‡] è®¾ç½®æ­¢ç›ˆ: ${take_profit:,.2f}")
                    # ä½¿ç”¨OKXçš„æ¡ä»¶å•APIè®¾ç½®æ­¢ç›ˆ
                    tp_order = self.data_fetcher.exchange.create_order(
                        symbol=symbol,
                        type='market',
                        side=close_side,
                        amount=amount,
                        params={
                            'tdMode': 'cross',
                            'posSide': pos_side,
                            'ordType': 'conditional',
                            'tpTriggerPx': str(take_profit),
                            'tpOrdPx': '-1',  # -1è¡¨ç¤ºå¸‚ä»·
                            'reduceOnly': True
                        }
                    )
                    print(f"[å®Œæˆ] æ­¢ç›ˆè®¾ç½®æˆåŠŸ: ${take_profit:,.2f}, è®¢å•ID: {tp_order.get('id', 'N/A')}")
                except Exception as e:
                    print(f"[è­¦å‘Š] æ­¢ç›ˆè®¾ç½®å¤±è´¥: {e}")
                    import traceback
                    traceback.print_exc()
            
        except Exception as e:
            print(f"[å¤±è´¥] å®ç›˜äº¤æ˜“æ‰§è¡Œå¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
    
    def run(self, interval: int = None):
        """
        è¿è¡Œä¸»å¾ªç¯
        
        Args:
            interval: å¾ªç¯é—´éš”ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ä»é…ç½®æ–‡ä»¶è¯»å–
        """
        if interval is None:
            interval = TRADING_CONFIG.get('cycle_interval', 300)
        
        print(f"\n{'='*70}")
        print(f"[å¯åŠ¨] å¼€å§‹è¿è¡Œ")
        print(f"   å¾ªç¯é—´éš”: {interval}ç§’")
        print(f"   æµ‹è¯•æ¨¡å¼: {'å¼€å¯' if TRADING_CONFIG.get('test_mode') else 'å…³é—­'}")
        print(f"{'='*70}\n")
        
        try:
            while True:
                # è¿è¡Œä¸€ä¸ªå‘¨æœŸ
                self.run_cycle()
                
                # æ¯10ä¸ªå‘¨æœŸå¯¼å‡ºä¸€æ¬¡MCPè®°å¿†
                if self.cycle_count % 10 == 0:
                    try:
                        if hasattr(self.ai_trader, 'mcp_filesystem') and hasattr(self.ai_trader, 'mcp_memory'):
                            self.ai_trader.mcp_filesystem.export_mcp_memory(self.ai_trader.mcp_memory)
                    except Exception as e:
                        print(f"[è­¦å‘Š] å¯¼å‡ºMCPè®°å¿†å¤±è´¥: {e}")
                
                # æ¯24å°æ—¶åŒæ­¥ä¸€æ¬¡MCPåˆ°æ•°æ®åº“
                if self.cycle_count % 288 == 0:  # å‡è®¾5åˆ†é’Ÿä¸€ä¸ªå‘¨æœŸï¼Œ288ä¸ªå‘¨æœŸ=24å°æ—¶
                    try:
                        synced = self.mcp_sync.auto_sync_if_needed(interval_hours=24)
                        if synced > 0:
                            print(f"[åŒæ­¥] å·²åŒæ­¥{synced}ç¬”äº¤æ˜“åˆ°æ•°æ®åº“")
                    except Exception as e:
                        print(f"[è­¦å‘Š] åŒæ­¥åˆ°æ•°æ®åº“å¤±è´¥: {e}")
                
                # å¯ä¸­æ–­çš„ç­‰å¾…
                print(f"â³ ç­‰å¾…{interval}ç§’åå¼€å§‹ä¸‹ä¸€ä¸ªå‘¨æœŸ...")
                print(f"   (æŒ‰ Ctrl+C åœæ­¢)\n")
                
                # åˆ†æ®µsleepï¼Œæ¯ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œä¾¿äºå¿«é€Ÿå“åº”Ctrl+C
                for i in range(interval):
                    time.sleep(1)
        
        except KeyboardInterrupt:
            print(f"\n\n{'='*70}")
            print("ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·")
            print(f"{'='*70}\n")
            self.stop()
    
    def stop(self):
        """åœæ­¢æœºå™¨äºº"""
        # AIç»Ÿè®¡
        ai_stats = self.ai_trader.get_conversation_stats()
        
        # äº¤æ˜“ç»Ÿè®¡
        trade_stats = self.trade_db.get_trade_statistics()
        
        print(f"[æ•°æ®] è¿è¡Œç»Ÿè®¡:")
        print(f"   æ€»å‘¨æœŸæ•°: {self.cycle_count}")
        print(f"   å¯¹è¯è½®æ•°: {ai_stats['total_rounds']}")
        print(f"   æ€»æ¶ˆæ¯æ•°: {ai_stats['total_messages']}")
        
        print(f"\n[ä¸Šæ¶¨] äº¤æ˜“ç»Ÿè®¡:")
        print(f"   æ€»äº¤æ˜“æ•°: {trade_stats['total_trades']}")
        print(f"   æœªå¹³ä»“: {trade_stats['open_trades']}")
        print(f"   å·²å¹³ä»“: {trade_stats['closed_trades']}")
        if trade_stats['closed_trades'] > 0:
            print(f"   èƒœç‡: {trade_stats['win_rate']:.1f}%")
            print(f"   æ€»ç›ˆäº: ${trade_stats['total_pnl']:.2f}")
        
        print(f"\n{'='*70}")
        print("ğŸ‘‹ äº¤æ˜“æœºå™¨äººå·²åœæ­¢")
        print(f"{'='*70}\n")


def main():
    """ä¸»å‡½æ•°"""
    bot = SimpleAITradingBot()
    
    # è¿è¡Œï¼ˆä»é…ç½®æ–‡ä»¶è¯»å–é—´éš”ï¼‰
    bot.run()


if __name__ == "__main__":
    main()
